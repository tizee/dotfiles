#!/usr/bin/env python3
"""Claude quota refresh daemon - pings Claude Code to trigger quota window reset.

Three modes:
1. Default mode: Healthcheck ping every 30 minutes (at :00 and :30 marks)
2. Scheduled mode: Ping at specified time, then auto-schedule next ping 5h later
   (aligns with Claude Code's sliding window quota reset mechanism)
3. Interval mode: Ping at regular intervals (e.g., every 1h30m)

Time format: 24-hour format (HH:MM, e.g., 08:00, 20:30)
Duration format: XhYmZs (e.g., 1h30m, 45m, 2h, 90s)

Usage:
    python3 claude_quota_daemon.py start [--time HH:MM]  # Start daemon
    python3 claude_quota_daemon.py start --interval 1h30m  # Start with interval
    python3 claude_quota_daemon.py stop                  # Stop daemon
    python3 claude_quota_daemon.py status                # Check status
    python3 claude_quota_daemon.py schedule HH:MM        # Update schedule (scheduled mode)
    python3 claude_quota_daemon.py interval 1h30m        # Set interval (interval mode)
    python3 claude_quota_daemon.py continue               # Switch to continuous mode
"""

import argparse
import os
import re
import signal
import subprocess
import sys
import time
import threading
from datetime import datetime, timedelta
from pathlib import Path


# Config
CONFIG_DIR = Path.home() / ".claude-quota"
PID_FILE = CONFIG_DIR / "daemon.pid"
LOG_FILE = CONFIG_DIR / "daemon.log"
STATE_FILE = CONFIG_DIR / "state.json"

SLIDING_WINDOW_HOURS = 5  # Claude Code quota window duration
FALLBACK_RETRY_MINUTES = 30  # Retry interval after all retries exhausted

# ANSI colors
RESET = "\033[0m"
GREEN = "\033[32m"
RED = "\033[31m"
CYAN = "\033[36m"
YELLOW = "\033[33m"
BOLD = "\033[1m"

# Global event for immediate wake-up
WAKEUP_EVENT = threading.Event()


def log(msg: str):
    """Write to log file with timestamp."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(LOG_FILE, "a") as f:
        f.write(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {msg}\n")


def parse_duration(duration_str: str) -> int:
    """Parse duration string (e.g., '1h2m3s', '45m', '90s') to seconds.

    Supports:
    - 1h30m (1 hour 30 minutes)
    - 45m (45 minutes)
    - 2h (2 hours)
    - 90s (90 seconds)
    - 1h2m3s (1 hour 2 minutes 3 seconds)

    Returns total seconds as integer.
    Raises ValueError for invalid format.
    """
    duration_str = duration_str.strip().lower()

    # Pattern matches: optional digits+h, optional digits+m, optional digits+s
    # Each component is optional but at least one must be present
    pattern = r"^((?P<hours>\d+)h)?((?P<minutes>\d+)m)?((?P<seconds>\d+)s)?$"
    match = re.match(pattern, duration_str)

    if not match:
        raise ValueError(f"Invalid duration format: {duration_str}")

    hours = int(match.group("hours") or 0)
    minutes = int(match.group("minutes") or 0)
    seconds = int(match.group("seconds") or 0)

    if hours == 0 and minutes == 0 and seconds == 0:
        raise ValueError(f"Duration must be > 0: {duration_str}")

    total_seconds = hours * 3600 + minutes * 60 + seconds
    return total_seconds


def format_duration(seconds: int) -> str:
    """Format seconds to human-readable duration string."""
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    secs = seconds % 60

    parts = []
    if hours > 0:
        parts.append(f"{hours}h")
    if minutes > 0:
        parts.append(f"{minutes}m")
    if secs > 0 or not parts:
        parts.append(f"{secs}s")
    return "".join(parts)


def check_claude_available() -> bool:
    """Check if Claude CLI is available and working."""
    try:
        result = subprocess.run(
            ["claude", "--version"], capture_output=True, timeout=10
        )
        return result.returncode == 0
    except Exception:
        return False


def get_state() -> dict:
    """Load daemon state."""
    if STATE_FILE.exists():
        import json

        with open(STATE_FILE) as f:
            return json.load(f)
    return {"mode": "continuous"}  # Default: every 30 minutes


def save_state(state: dict):
    """Save daemon state."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    import json

    with open(STATE_FILE, "w") as f:
        json.dump(state, f)


def ping_claude() -> bool:
    """Ping Claude Code using Haiku with minimal tokens."""
    log("Pinging Claude Code (haiku)...")
    try:
        result = subprocess.run(
            [
                "claude",
                "--model",
                "haiku",
                "--system-prompt",
                "Reply pong",
                "--tools",
                "",
                "--no-session-persistence",
                "--permission-mode",
                "bypassPermissions",
                "-p",
                "ping",
            ],
            capture_output=True,
            timeout=30,
        )
        if result.returncode == 0:
            log("Ping successful! Quota window triggered.")
            return True
        else:
            log(f"Ping failed with exit code {result.returncode}")
            return False
    except Exception as e:
        log(f"Ping error: {e}")
        return False


def wait_for_next_slot(state: dict) -> str:
    """Calculate wait time until next ping slot. Returns next_time_str."""
    while True:
        now = datetime.now()
        mode = state.get("mode", "continuous")

        if mode == "continuous":
            # Ping every 30 minutes at :00 and :30
            minute = now.minute
            next_minute = 30 if minute < 30 else 60
            if next_minute == 60:
                target = now.replace(second=0, microsecond=0) + timedelta(hours=1)
                target = target.replace(minute=0)
            else:
                target = now.replace(second=0, microsecond=0, minute=30)

        elif mode == "interval":
            # Ping at regular intervals
            interval_seconds = state.get("interval_seconds", 1800)
            target = now + timedelta(seconds=interval_seconds)

        else:  # scheduled mode
            scheduled_time = state.get("scheduled_time", "00:00:00")
            parts = list(map(int, scheduled_time.split(":")))
            h = parts[0]
            m = parts[1]
            s = parts[2] if len(parts) > 2 else 0
            target = now.replace(hour=h, minute=m, second=s, microsecond=0)

            # If target has passed today, schedule for tomorrow
            if target <= now:
                target += timedelta(days=1)

        wait_seconds = (target - now).total_seconds()

        if mode == "interval":
            next_time_str = format_duration(int(wait_seconds))
            log(f"Next ping in {next_time_str}")
        else:
            next_time_str = target.strftime("%H:%M:%S")
            log(
                f"Next ping at {target.strftime('%Y-%m-%d %H:%M:%S')} (in {wait_seconds:.0f}s)"
            )

        # Wait until target time or signal
        WAKEUP_EVENT.clear()
        signaled = WAKEUP_EVENT.wait(timeout=wait_seconds)

        if signaled:
            log("Wake-up signal received, reloading state...")
            state = get_state()

            mode = state.get("mode", "continuous")
            if mode == "scheduled":
                log(
                    f"Mode changed to: scheduled at {state.get('scheduled_time', 'N/A')}"
                )
            elif mode == "interval":
                interval_str = format_duration(state.get("interval_seconds", 1800))
                log(f"Mode changed to: interval every {interval_str}")
            else:
                log("Mode changed to: continuous")
            continue  # Recalculate with new state

        return next_time_str


def update_next_scheduled_time(state: dict):
    """Update state with next scheduled time (5 hours later) for scheduled mode."""
    if state.get("mode") == "scheduled":
        current_time = state.get("scheduled_time", "00:00:00")
        parts = list(map(int, current_time.split(":")))
        h = parts[0]
        m = parts[1]
        s = parts[2] if len(parts) > 2 else 0

        # Base next time on the scheduled time that just triggered
        base_time = datetime.now().replace(hour=h, minute=m, second=s, microsecond=0)
        if base_time > datetime.now():
            base_time -= timedelta(days=1)

        next_time = base_time + timedelta(hours=SLIDING_WINDOW_HOURS)
        state["scheduled_time"] = next_time.strftime("%H:%M:%S")
        save_state(state)
        log(
            f"Next scheduled time updated to {state['scheduled_time']} (+{SLIDING_WINDOW_HOURS}h)"
        )


def daemon_loop():
    """Main daemon loop."""
    log("Daemon started")

    # Set up signal handler for wake-up
    signal.signal(signal.SIGUSR1, lambda sig, frame: WAKEUP_EVENT.set())

    state = get_state()
    mode = state.get("mode", "continuous")
    if mode == "scheduled":
        log(f"Mode: scheduled at {state.get('scheduled_time', 'N/A')}")
    elif mode == "interval":
        interval_str = format_duration(state.get("interval_seconds", 1800))
        log(f"Mode: interval every {interval_str}")
    else:
        log("Mode: continuous (every 30 min)")

    while True:
        # Check if we're in fallback retry mode (previous attempts all failed)
        in_fallback = state.get("fallback_retry", False)

        if in_fallback:
            # Fallback mode: wait shorter interval before retrying
            fallback_seconds = FALLBACK_RETRY_MINUTES * 60
            log(f"Fallback mode: retrying in {FALLBACK_RETRY_MINUTES}m...")
            WAKEUP_EVENT.clear()
            WAKEUP_EVENT.wait(timeout=fallback_seconds)
        else:
            # Normal mode: wait for next scheduled slot
            wait_for_next_slot(state)

        # Reload state after wait
        state = get_state()

        # Retry logic for rate limiting
        max_retries = 12
        retry_interval = 300  # 5 minutes
        success = False

        for i in range(1, max_retries + 1):
            if ping_claude():
                success = True
                break
            if i < max_retries:
                log(f"Retry {i}/{max_retries} in {retry_interval}s...")
                time.sleep(retry_interval)

        if success:
            # Clear fallback mode and update to next +5h slot
            if state.get("fallback_retry"):
                log("Recovered from fallback mode")
                state.pop("fallback_retry", None)
                save_state(state)
            update_next_scheduled_time(state)
        else:
            # All retries failed - enter fallback mode, don't skip to +5h
            log(
                f"WARNING: All {max_retries} retries failed! Entering fallback mode (retry every {FALLBACK_RETRY_MINUTES}m)"
            )
            state["fallback_retry"] = True
            save_state(state)


def start_daemon():
    """Start the daemon in background."""
    # Check if Claude CLI is available
    if not check_claude_available():
        print(f"● {RED}error{RESET} - claude CLI not found or not working")
        print("   Please install Claude Code CLI first:")
        print("   https://code.anthropic.com/docs")
        sys.exit(1)

    if PID_FILE.exists():
        pid = int(PID_FILE.read_text())
        try:
            os.kill(pid, 0)  # Check if process exists
            print(f"● {GREEN}active (running){RESET} - already running (PID {pid})")
            return
        except OSError:
            PID_FILE.unlink()

    pid = os.fork()
    if pid > 0:
        # Parent: save PID and exit
        CONFIG_DIR.mkdir(parents=True, exist_ok=True)
        PID_FILE.write_text(str(pid))
        print(f"● {GREEN}active (running){RESET} - started (PID {pid})")
        sys.exit(0)

    # Child: daemonize
    os.setsid()
    os.umask(0)

    # Redirect stdin/stdout/stderr
    sys.stdin.close()
    sys.stdout.close()
    sys.stderr.close()

    # Set up signal handlers
    signal.signal(signal.SIGTERM, lambda sig, frame: sys.exit(0))
    signal.signal(signal.SIGINT, lambda sig, frame: sys.exit(0))

    try:
        daemon_loop()
    finally:
        PID_FILE.unlink(missing_ok=True)


def stop_daemon():
    """Stop the daemon."""
    if not PID_FILE.exists():
        print(f"● {RED}inactive{RESET} (dead) - not running")
        return

    pid = int(PID_FILE.read_text())
    try:
        os.kill(pid, signal.SIGTERM)
        print(f"● {RED}inactive{RESET} (dead) - stopped (PID {pid})")
        PID_FILE.unlink()
    except OSError as e:
        print(f"● {RED}inactive{RESET} (dead) - failed to stop: {e}")
        PID_FILE.unlink(missing_ok=True)


def show_status():
    """Show daemon status in systemctl-style format."""
    if not PID_FILE.exists():
        print(f"● {RED}inactive{RESET} (dead)")
        print("   Loaded: not running")
        return

    pid = int(PID_FILE.read_text())
    try:
        os.kill(pid, 0)
        state = get_state()
        mode = state.get("mode", "continuous")

        print(f"● {GREEN}active (running){RESET}")
        print(f"   {BOLD}PID:{RESET} {pid}")

        if mode == "scheduled":
            time = state.get("scheduled_time", "N/A")
            print(f"   {BOLD}Mode:{RESET} scheduled at {CYAN}{time}{RESET} (auto +5h)")
        elif mode == "interval":
            interval = state.get("interval_seconds", 1800)
            interval_str = format_duration(interval)
            print(f"   {BOLD}Mode:{RESET} interval every {CYAN}{interval_str}{RESET}")
        else:
            print(f"   {BOLD}Mode:{RESET} continuous (every 30 min at :00/:30)")

        # Show fallback status if active
        if state.get("fallback_retry"):
            print(
                f"   {BOLD}Status:{RESET} {YELLOW}FALLBACK{RESET} (retrying every {FALLBACK_RETRY_MINUTES}m until success)"
            )

        print(f"   {BOLD}Log:{RESET} {LOG_FILE}")
        print(f"   {BOLD}State:{RESET} {STATE_FILE}")

    except OSError:
        print(f"● {RED}inactive{RESET} (dead)")
        print(f"   {YELLOW}Warning:{RESET} stale PID file")
        PID_FILE.unlink()


def _format_mode_info(state: dict) -> str:
    """Format mode info for display (used in mode change messages)."""
    mode = state.get("mode", "continuous")
    if mode == "scheduled":
        return f"{YELLOW}scheduled at {state.get('scheduled_time', 'N/A')}{RESET}"
    elif mode == "interval":
        interval = state.get("interval_seconds", 1800)
        interval_str = format_duration(interval)
        return f"{YELLOW}interval every {interval_str}{RESET}"
    else:
        return f"{YELLOW}continuous{RESET}"


def _change_mode(new_mode: str, new_mode_display: str, state_updater: callable):
    """Common logic for changing daemon mode.

    Args:
        new_mode: Mode name ('scheduled', 'interval', 'continuous')
        new_mode_display: Formatted display string for the new mode
        state_updater: Function that takes state dict and applies mode-specific updates
    """
    state = get_state()
    old_mode = state.get("mode", "continuous")
    old_mode_info = _format_mode_info(state)
    state_updater(state)
    save_state(state)

    # Signal daemon to wake up if it's running
    if PID_FILE.exists():
        try:
            pid = int(PID_FILE.read_text())
            os.kill(pid, signal.SIGUSR1)
        except (ValueError, ProcessLookupError, PermissionError):
            pass

    log(f"Mode changed: {old_mode} -> {new_mode}")
    print(f"● Mode changed: {old_mode_info} {RESET}-> {new_mode_display}")


def resolve_scheduled_time(input_str: str) -> str:
    """Resolve input string to HH:MM:SS format. Supports HH:MM[:SS] and duration (1h, 30m, 45s)."""
    for fmt in ("%H:%M:%S", "%H:%M"):
        try:
            dt = datetime.strptime(input_str, fmt)
            return dt.strftime("%H:%M:%S")
        except ValueError:
            continue

    try:
        seconds = parse_duration(input_str)
        target_dt = datetime.now() + timedelta(seconds=seconds)
        return target_dt.strftime("%H:%M:%S")
    except ValueError:
        print(f"Invalid format: {input_str}")
        print("Use HH:MM[:SS] (e.g. 14:30:05) or duration (e.g. 1h30m, 45s)")
        sys.exit(1)


def schedule_time(time_str: str):
    """Update scheduled ping time (switches to scheduled mode)."""
    target_time = resolve_scheduled_time(time_str)

    def update_state(state):
        state["mode"] = "scheduled"
        state["scheduled_time"] = target_time

    _change_mode(
        "scheduled", f"{CYAN}scheduled at {target_time}{RESET} (auto +5h)", update_state
    )
    # If daemon is running, it will pick up the change on next loop


def continue_mode():
    """Switch to continuous mode (every 30 minutes)."""

    def update_state(state):
        state["mode"] = "continuous"
        state.pop("scheduled_time", None)
        state.pop("interval_seconds", None)

    _change_mode(
        "continuous",
        f"{GREEN}continuous{RESET} (every 30 min at :00/:30)",
        update_state,
    )
    # If daemon is running, it will pick up the change on next loop


def interval_mode(duration_str: str):
    """Set interval mode (switches to interval mode)."""
    try:
        interval_seconds = parse_duration(duration_str)
    except ValueError as e:
        print(f"Invalid duration format: {e}")
        print("Expected format: 1h30m, 45m, 90s, etc.")
        sys.exit(1)

    interval_display = format_duration(interval_seconds)

    def update_state(state):
        state["mode"] = "interval"
        state["interval_seconds"] = interval_seconds
        state.pop("scheduled_time", None)

    _change_mode(
        "interval", f"{CYAN}interval every {interval_display}{RESET}", update_state
    )
    # If daemon is running, it will pick up the change on next loop


def main():
    format_info = """
Time format:
  HH:MM[:SS] (24-hour format, e.g., 08:00, 20:30, 01:59:45)
  DURATION (relative to now, e.g., 1h, 30m, 45s)

Duration format (for interval):
  XhYmZs (e.g., 1h30m, 45m, 2h, 90s)
"""
    parser = argparse.ArgumentParser(
        description="Claude quota refresh daemon - keeps quota window active",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"{format_info}\nExamples:\n  ./claude-quota start --time 08:00\n  ./claude-quota schedule 1h30m\n  ./claude-quota interval 45m\n  ./claude-quota status",
    )
    subparsers = parser.add_subparsers(dest="command", help="Command")

    # Start command
    start_parser = subparsers.add_parser(
        "start",
        help="Start daemon",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=format_info,
    )
    start_parser.add_argument(
        "--time",
        metavar="TIME",
        help="Start in scheduled mode (HH:MM or duration, e.g., 1h)",
    )
    start_parser.add_argument(
        "--interval",
        metavar="DURATION",
        help="Start in interval mode, e.g., 1h30m, 45m, 90s",
    )

    # Other commands
    subparsers.add_parser("stop", help="Stop daemon")
    subparsers.add_parser("status", help="Show status")
    subparsers.add_parser("continue", help="Switch to continuous mode")

    schedule_parser = subparsers.add_parser(
        "schedule",
        help="Update schedule (switch to scheduled mode)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=format_info,
    )
    schedule_parser.add_argument(
        "time", metavar="TIME", help="Schedule time (HH:MM or duration, e.g., 1h)"
    )

    interval_parser = subparsers.add_parser(
        "interval",
        help="Set interval (switch to interval mode)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=format_info,
    )
    interval_parser.add_argument(
        "duration", metavar="DURATION", help="Interval duration (e.g., 1h30m, 45m)"
    )

    args = parser.parse_args()

    if args.command == "start":
        if args.time and args.interval:
            print("Error: Cannot use both --time and --interval")
            sys.exit(1)
        if args.time:
            # Set scheduled mode
            state = get_state()
            state["mode"] = "scheduled"
            state["scheduled_time"] = resolve_scheduled_time(args.time)
            save_state(state)
        elif args.interval:
            # Set interval mode
            state = get_state()
            try:
                state["mode"] = "interval"
                state["interval_seconds"] = parse_duration(args.interval)
                save_state(state)
            except ValueError as e:
                print(f"Invalid interval format: {e}")
                sys.exit(1)
        start_daemon()
    elif args.command == "stop":
        stop_daemon()
    elif args.command == "status":
        show_status()
    elif args.command == "continue":
        continue_mode()
    elif args.command == "schedule":
        schedule_time(args.time)
    elif args.command == "interval":
        interval_mode(args.duration)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
