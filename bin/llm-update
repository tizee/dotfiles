#!/usr/bin/env python3
"""Interactive TUI upgrader for AI CLI tools with async version fetching and live UI updates."""

import asyncio
import json
import os
import re
import signal
import sys
from dataclasses import dataclass
from typing import Optional
import subprocess
import urllib.request


def handle_sigint(sig, frame):
    """Global SIGINT handler for immediate exit."""
    # Ensure we move to a new line before printing
    sys.stdout.write(f"\n{Colors.YELLOW}Interrupted.{Colors.RESET}\n")
    sys.stdout.flush()
    os._exit(0)


# Register the handler as early as possible
signal.signal(signal.SIGINT, handle_sigint)


@dataclass
class Tool:
    name: str
    desc: str
    cmd: str
    dep: str
    pkg: str
    tag: str


TOOLS = [
    Tool("claude(brew)", "Claude Code CLI",
         "brew upgrade claude-code",
         "brew", "claude-code", "latest"),
    Tool("codex(pnpm)", "OpenAI Codex CLI",
         "pnpm install -g @openai/codex@latest",
         "pnpm", "@openai/codex", "latest"),
    Tool("gemini(pnpm)", "Google Gemini CLI",
         "pnpm install -g @google/gemini-cli@nightly",
         "pnpm", "@google/gemini-cli", "nightly"),
    Tool("kimi-cli(uv)", "Kimi CLI",
         "uv tool upgrade --no-cache kimi-cli",
         "uv", "kimi-cli", ""),
]


# Colors
class Colors:
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    CYAN = '\033[36m'
    GRAY = '\033[90m'


# Box drawing and spinners
BOX = {
    'dot': '•', 'arrow': '→', 'check': '✓', 'cross': '✗'
}

SPINNER_CHARS = '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'


def get_terminal_width() -> int:
    """Get terminal width."""
    try:
        return int(subprocess.run(["tput", "cols"], capture_output=True).stdout.decode().strip())
    except Exception:
        return 80


def print_header(width: int):
    """Print a simple header."""
    print("\033[2J\033[H", end="")  # Clear screen, home cursor
    print(f"{Colors.BOLD}{Colors.CYAN}LLM Tools Updater{Colors.RESET}")
    print(f"{Colors.DIM}{'─' * 60}{Colors.RESET}")
    print()


def check_dependency(dep: str) -> bool:
    """Check if a command dependency exists."""
    try:
        result = subprocess.run(
            ["which", dep],
            capture_output=True,
            check=False
        )
        return result.returncode == 0
    except Exception:
        return False


UPDATE_LOCK = asyncio.Lock()
# Global state to track tool info and loading status
TOOL_DATA = []  # List of dicts: {current, latest, has_dep, loading}


async def update_line(index: int, total: int, content: str):
    """Update a specific line in the tool list safely."""
    async with UPDATE_LOCK:
        # Distance from current cursor position (below the help/prompt) to the target line
        # Total lines in list: total
        # Offset from prompt to bottom of list is about 8 lines (help text)
        # We use SCO/RCO to be safer.
        up = (total - index + 1) + 8  # 8 is the size of help section
        
        sys.stdout.write("\033[s")  # Save cursor position
        sys.stdout.write(f"\033[{up}A")  # Move up to target line
        sys.stdout.write("\r\033[K")  # Clear line
        sys.stdout.write(content)
        sys.stdout.write("\033[u")  # Restore cursor position
        sys.stdout.flush()


async def spinner_animation_task():
    """Background task to animate spinners for tools that are loading."""
    frame = 0
    while True:
        for i in range(len(TOOLS)):
            if TOOL_DATA[i]['loading']:
                spinner = SPINNER_CHARS[frame % len(SPINNER_CHARS)]
                content = format_tool_line_with_state(i + 1, spinner)
                await update_line(i + 1, len(TOOLS), content)
        await asyncio.sleep(0.1)
        frame += 1


def format_tool_line_with_state(index: int, spinner: str = None) -> str:
    """Format a tool line based on the current global TOOL_DATA state."""
    tool = TOOLS[index - 1]
    data = TOOL_DATA[index - 1]
    
    status_icon = ""
    version_text = ""
    status_text = ""

    if data['loading']:
        status_icon = f"{Colors.CYAN}{spinner or SPINNER_CHARS[0]}{Colors.RESET}"
        version_text = f" {Colors.DIM}fetching...{Colors.RESET}"
    elif not data['has_dep']:
        status_icon = f"{Colors.RED}!{Colors.RESET}"
        status_text = f" {Colors.DIM}({tool.dep} not found){Colors.RESET}"
    elif data['current'] is None and not data['loading']:
        status_icon = f"{Colors.YELLOW}!{Colors.RESET}"
        version_text = f" {Colors.DIM}(not installed){Colors.RESET}"
    elif data['latest'] is None and not data['loading']:
        status_icon = f"{Colors.RED}?{Colors.RESET}"
        version_text = f" {Colors.RED}(unknown/network error){Colors.RESET}"
        if data['current']:
            version_text = f" {Colors.DIM}(ver: {data['current']}){Colors.RESET} {Colors.RED}(latest: error){Colors.RESET}"
    elif data['current'] == data['latest']:
        status_icon = f"{Colors.GREEN}{BOX['check']}{Colors.RESET}"
        version_text = f" {Colors.GREEN}{data['current']}{Colors.RESET} {Colors.DIM}(latest: {data['latest']}){Colors.RESET}"
    else:
        status_icon = f"{Colors.YELLOW}{BOX['arrow']}{Colors.RESET}"
        version_text = f" {Colors.YELLOW}{data['current']}{Colors.RESET} {Colors.DIM}->{Colors.RESET} {Colors.GREEN}{data['latest']}{Colors.RESET}"

    base = f"  {Colors.BOLD}{index}){Colors.RESET} {status_icon} {tool.name:<12} {Colors.GRAY}{tool.desc:<20}{Colors.RESET}{version_text}{status_text}"
    return base


async def get_current_version(tool: Tool) -> Optional[str]:
    """Get current installed version async."""
    try:
        if tool.dep == "brew":
            proc = await asyncio.create_subprocess_exec(
                "brew", "info", tool.pkg,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.DEVNULL
            )
            stdout, _ = await proc.communicate()
            output = stdout.decode().strip()
            # Output format: "==> claude-code: 2.0.37"
            match = re.search(r'(\d+\.\d+\.\d+)', output)
            if match:
                return match.group(1)

        elif tool.dep == "pnpm":
            proc = await asyncio.create_subprocess_exec(
                "pnpm", "list", "-g", tool.pkg, "--depth=0",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.DEVNULL
            )
            stdout, _ = await proc.communicate()
            output = stdout.decode()
            for line in output.split('\n'):
                if tool.pkg in line:
                    parts = line.split()
                    try:
                        pkg_idx = next(i for i, p in enumerate(parts) if p == tool.pkg)
                        if pkg_idx + 1 < len(parts):
                            return parts[pkg_idx + 1]
                    except StopIteration:
                        continue

        elif tool.dep == "uv":
            proc = await asyncio.create_subprocess_exec(
                "uv", "tool", "list",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.DEVNULL
            )
            stdout, _ = await proc.communicate()
            output = stdout.decode()
            for line in output.split('\n'):
                if tool.pkg in line:
                    parts = line.split()
                    try:
                        pkg_idx = next(i for i, p in enumerate(parts) if p == tool.pkg)
                        if pkg_idx + 1 < len(parts):
                            return parts[pkg_idx + 1].lstrip('v')
                    except StopIteration:
                        continue
    except Exception:
        pass
    return None


def fetch_pypi_version(pkg: str) -> Optional[str]:
    """Sync fetch from PyPI."""
    try:
        url = f"https://pypi.org/pypi/{pkg}/json"
        with urllib.request.urlopen(url, timeout=5) as response:
            data = json.loads(response.read().decode())
            return data["info"]["version"]
    except Exception:
        return None


async def get_latest_version(tool: Tool) -> Optional[str]:
    """Get latest version from registry async."""
    try:
        if tool.dep == "brew":
            # For Homebrew-installed Claude Code, parse output of 'claude update'
            proc = await asyncio.create_subprocess_exec(
                "claude", "update",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await proc.communicate()
            output = stdout.decode().strip()
            # Look for "Update available: x.y.z -> a.b.c"
            match = re.search(r'Update available: [\d.]+\s*->\s*([\d.]+)', output)
            if match:
                return match.group(1)
            # If already up to date, get current version
            match = re.search(r'Current version: ([\d.]+)', output)
            if match:
                return match.group(1)

        elif tool.dep == "pnpm":
            target = f"{tool.pkg}@{tool.tag}" if tool.tag else tool.pkg
            proc = await asyncio.create_subprocess_exec(
                "pnpm", "view", target, "version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.DEVNULL
            )
            stdout, _ = await proc.communicate()
            version = stdout.decode().strip()
            return version if version else None

        elif tool.dep == "uv":
            loop = asyncio.get_event_loop()
            return await loop.run_in_executor(None, fetch_pypi_version, tool.pkg)
    except Exception:
        pass
    return None


def print_help(width: int):
    """Print help section at bottom."""
    print()
    print(f"{Colors.DIM}{'─' * 60}{Colors.RESET}")
    print(f"\n{Colors.BOLD}Options:{Colors.RESET}")
    print(f"  {BOX['dot']} Enter numbers (space-separated): {Colors.CYAN}1 3{Colors.RESET}")
    print(f"  {BOX['dot']} Press {Colors.CYAN}Enter{Colors.RESET} to update all available tools")
    print(f"  {BOX['dot']} Press {Colors.CYAN}q{Colors.RESET} to quit")
    print()


async def run_upgrade_serial(tool: Tool) -> bool:
    """Run upgrade command for a tool and preserve original ANSI styles."""
    print(f"\n{Colors.DIM}{'─' * 60}{Colors.RESET}")
    print(f"{Colors.BOLD}{BOX['arrow']} Upgrading {Colors.CYAN}{tool.name}{Colors.RESET}")
    print(f"{Colors.DIM}{tool.desc}{Colors.RESET}")
    print(f"{Colors.GRAY}$ {tool.cmd}{Colors.RESET}")
    print(f"{Colors.DIM}{'─' * 60}{Colors.RESET}\n")

    try:
        # Run process and let it inherit stdout/stderr to preserve ANSI/colors/progress
        proc = await asyncio.create_subprocess_shell(tool.cmd)
        await proc.wait()
        success = proc.returncode == 0
        
        if success:
            print(f"\n{Colors.GREEN}{BOX['check']} Successfully upgraded {tool.name}{Colors.RESET}")
        else:
            print(f"\n{Colors.RED}{BOX['cross']} Failed to upgrade {tool.name}{Colors.RESET}")
            
    except Exception as e:
        print(f"\n{Colors.RED}{BOX['cross']} Error: {e}{Colors.RESET}")
        success = False

    return success


def print_summary(success_list: list[str], fail_list: list[str], width: int):
    """Print upgrade summary."""
    print(f"\n{Colors.DIM}{'─' * 60}{Colors.RESET}")
    print(f"\n{Colors.BOLD}Summary:{Colors.RESET}\n")

    if success_list:
        print(f"{Colors.GREEN}{BOX['check']} Succeeded ({len(success_list)}):{Colors.RESET}")
        for tool in success_list:
            print(f"  {BOX['dot']} {tool}")
        print()

    if fail_list:
        print(f"{Colors.RED}{BOX['cross']} Failed ({len(fail_list)}):{Colors.RESET}")
        for tool in fail_list:
            print(f"  {BOX['dot']} {tool}")
        print()

    if not fail_list:
        print(f"{Colors.GREEN}{Colors.BOLD}All updates completed successfully!{Colors.RESET}")


async def fetch_tool_info_background(index: int):
    """Fetch tool info and update global state."""
    tool = TOOLS[index - 1]
    has_dep = check_dependency(tool.dep)
    
    if not has_dep:
        TOOL_DATA[index - 1].update({'loading': False, 'has_dep': False})
        content = format_tool_line_with_state(index)
        await update_line(index, len(TOOLS), content)
        return

    # Fetch versions
    current, latest = await asyncio.gather(
        get_current_version(tool),
        get_latest_version(tool)
    )

    TOOL_DATA[index - 1].update({
        'loading': False,
        'current': current,
        'latest': latest,
        'has_dep': True
    })
    
    content = format_tool_line_with_state(index)
    await update_line(index, len(TOOLS), content)


async def main_async():
    """Main async function."""
    width = get_terminal_width()
    print_header(width)
    
    # Initialize global state
    global TOOL_DATA
    TOOL_DATA = [{
        'current': None,
        'latest': None,
        'has_dep': True,
        'loading': True
    } for _ in TOOLS]

    print(f"{Colors.BOLD}Available tools:{Colors.RESET}\n")
    for i in range(1, len(TOOLS) + 1):
        print(format_tool_line_with_state(i))
    
    print_help(width)

    # Start background tasks
    spinner_task = asyncio.create_task(spinner_animation_task())
    fetch_tasks = [asyncio.create_task(fetch_tool_info_background(i)) for i in range(1, len(TOOLS) + 1)]

    # Async input handling
    loop = asyncio.get_event_loop()
    try:
        sys.stdout.write(f"{Colors.BOLD}{BOX['arrow']} Your choice:{Colors.RESET} ")
        sys.stdout.flush()
        user_input_raw = await loop.run_in_executor(None, sys.stdin.readline)
        if not user_input_raw:  # EOF
            print(f"\n{Colors.YELLOW}Cancelled.{Colors.RESET}")
            os._exit(0)
        user_input = user_input_raw.strip()
    except EOFError:
        print(f"\n{Colors.YELLOW}Cancelled.{Colors.RESET}")
        os._exit(0)

    # Stop background animations
    spinner_task.cancel()
    for t in fetch_tasks:
        t.cancel()

    if user_input.lower() in ('q', 'quit', 'exit'):
        print(f"\n{Colors.YELLOW}Cancelled.{Colors.RESET}")
        sys.exit(0)

    # Parse selection
    selected = []
    if not user_input:
        selected = [i for i, _ in enumerate(TOOLS, 1) if TOOL_DATA[i-1]['has_dep']]
    else:
        for token in user_input.split():
            if token.isdigit() and 1 <= int(token) <= len(TOOLS):
                selected.append(int(token))

    if not selected:
        print(f"\n{Colors.RED}{BOX['cross']} No valid tools selected.{Colors.RESET}")
        sys.exit(1)

    # Confirm selection
    print(f"\n{Colors.BOLD}Selected tools:{Colors.RESET}", end=" ")
    for idx in selected:
        print(f"{Colors.CYAN}{TOOLS[idx - 1].name}{Colors.RESET}", end=" ")
    print()

    try:
        sys.stdout.write(f"{Colors.BOLD}Proceed? [Y/n]:{Colors.RESET} ")
        sys.stdout.flush()
        confirm_raw = await loop.run_in_executor(None, sys.stdin.readline)
        confirm = confirm_raw.strip().lower()
    except EOFError:
        confirm = "y"

    if confirm.startswith('n'):
        print(f"\n{Colors.YELLOW}Cancelled.{Colors.RESET}")
        sys.exit(0)

    # Run upgrades sequentially
    success_list = []
    fail_list = []

    for idx in selected:
        tool = TOOLS[idx - 1]
        success = await run_upgrade_serial(tool)
        if success:
            success_list.append(tool.name)
        else:
            fail_list.append(tool.name)

    print_summary(success_list, fail_list, width)

    if fail_list:
        sys.exit(1)
    sys.exit(0)


def main():
    """Entry point."""
    asyncio.run(main_async())


if __name__ == "__main__":
    main()
