# Types
snippet opt "Option<T>"
	Option<${1:i32}>
endsnippet

snippet res "<T>"
	Result<${1:i32}, ${2:()}>
endsnippet

# syntax/control flow
snippet let "let variable " b
let ${1:var} = $0;
endsnippet

snippet letm "let variable " b
let mut ${1:var} = $0;
endsnippet

snippet matchr "match Result" b
match ${1:result} {
	Ok(${2:data}) => { $3 } 
	Err(${3:error}) => { $4 }
} 
endsnippet

snippet struct "struct name" b
struct $1 {
$0
}
endsnippet

snippet fn "fn name(?) -> ? {}"
fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet pfn "pub fn name(?) -> ? {}"
pub fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet afn "async fn name(?) -> ? {}"
async fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet pafn "pub async fn name(?) -> ? {}"
pub async fn ${1:function_name}($2)${3/..*/ -> /}$3 {
	${VISUAL}$0
}
endsnippet

snippet fmt "format!(..)"
format!("$1"${2/..*/, /}$2);
endsnippet

snippet .it ".iter()" i
.iter()$0
endsnippet

snippet impl "Struct/Trait implementation" b
impl$4 ${1:Type/Trait}${2: for ${3:Type}}${4:<${5:T}>} {
	${0}
}
endsnippet

snippet enum "enum definition" b
	enum ${1:Name} {
		${2},
	}
endsnippet

snippet penum "pub enum" b
	pub enum ${1:Name} {
		${2},
	}
endsnippet

snippet trait "trait definition" b
trait ${1:Name} {
	${0}
}
endsnippet

snippet forin "for in loop" b
for ${1:i} in $2 {
	$0
} 
endsnippet

snippet loop "loop {}"
loop {
	${0:${VISUAL}}
}
endsnippet

snippet wh "while loop"
while ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

snippet whl "while let loop"
	while let ${1:Some($2)} = $3 {
		${0:${VISUAL}}
	}
endsnippet

snippet case "case clause for pattern match" b
	${1:_} => ${2:expression}
endsnippet

snippet todo "TODO comment" b
// TODO: $0
endsnippet

snippet if "if"
	if ${1} {
		${0:${VISUAL}}
	}
endsnippet

snippet ife "if-else"
	if ${1} {
		${2:${VISUAL}}
	} else {
		${0}
	}
endsnippet

snippet el "else"
	else {
		${0:${VISUAL}}
	}
endsnippet

snippet eli "else if"
	else if {
		${0:${VISUAL}}
	}
endsnippet

snippet mat "match pattern"
	match ${1} {
		${2} => ${3}
	}
endsnippet

snippet ifl "if let" b
if let ${1:Some($2)} = $3 {
	${0:${VISUAL}}
}
endsnippet

# macros
snippet pri "print!(..)" b
print!("$1"${2/..*/, /}$2);
endsnippet

snippet pln "println!(..)" b
println!("$1"${2/..*/, /}$2);
endsnippet

snippet pdb "debug println! {:?}" b
println!("$1 = {:?}", $1);
endsnippet

snippet pdbs "debug println! {:#?}" b
println!("$1 = {:#?}", $1);
endsnippet

snippet ass "assert! macro" b
assert!($1);
endsnippet

snippet asse "assert_eq! macro" b
assert_eq!($1,$2);
endsnippet

snippet vec "vec! marco"
vec![$1]
endsnippet

snippet unim "unimplemented! macro with TODO" b
unimplemented!() // TODO
endsnippet

# attributes
snippet ig "#[ignore]" b
#[ignore]
endsnippet

snippet cfg "#[cfg(...)] " b
#[cfg(${1:target_os = "linux"})]
endsnippet

snippet feat "#![feature]" b
#![feature(${1:plugin})]
endsnippet

snippet der "#[derive(...)]" b
#[derive(${1:Debug})]
endsnippet

snippet attr "#[...]" b
#[${1:inline}]
endsnippet

# testing
snippet testm "test module" b
	#[cfg(test)]
	mod test_${1:super}{
		use super::${2:*};
		#[test]
		fn test_$3{
			$4
		}
	}
endsnippet

snippet testfn "test function" b
#[test]
fn test_$1(){
	$2
}
endsnippet

# vim:ft=snippets:
