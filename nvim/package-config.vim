" package-config.vim - merged plugin configs
scriptencoding utf-8

" Generated by merging configs/*.vim

" === init-packages.vim === {{{
" File: init-packages.vim
" Author: tizee
" Email: 33030965+tizee@users.noreply.github.com
" Description: package list
" run-once
if !exists('g:loaded_tz_packages') && !&cp && v:version >= 700
  let g:loaded_tz_packages= 1

call plug#begin('~/.vim/plugged')
" Plugin list {{{

" ===> nvim plugin {{{
if has('nvim')
  " -- treesitter highlighter
  Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
  " treesitter-based textojbects
  Plug 'nvim-treesitter/nvim-treesitter-textobjects'
  " rename
  Plug 'nvim-treesitter/nvim-treesitter-refactor'
endif
"  }}}

" ===> Formatter/Linter {{{
" Chinese formatter
Plug 'hotoo/pangu.vim'
" -- editorconfig
Plug 'editorconfig/editorconfig-vim'
" open-source grammar checker (alternative of Grammarly)
" Plug 'dpelle/vim-LanguageTool'
" }}}

" ===> language Syntax highlighting or more {{{
" -- pug/Jade
Plug 'digitaltoad/vim-pug'
" -- nginx syntax
Plug 'chr4/nginx.vim'
" -- toml
Plug 'cespare/vim-toml'
" -- glsl
Plug 'tikhomirov/vim-glsl' " OpenGL shader language
" -- colored parentheses
Plug 'luochen1990/rainbow'
" -- json
Plug 'elzr/vim-json'
" -- jsonc
Plug 'kevinoid/vim-jsonc'
" ziglang
Plug 'ziglang/zig.vim'
" beancount
Plug 'nathangrigg/vim-beancount'
" cmake
Plug 'pboettch/vim-cmake-syntax'
" }}}

" ===> Enhanced Editing Workflow {{{
" -- commenting mappings
Plug 'tpope/vim-commentary'
" -- edit surrounding symbol pairs
Plug 'tpope/vim-surround'
" -- quick navigation
Plug 'easymotion/vim-easymotion'
" -- quick alignment
Plug 'godlygeek/tabular'
" -- display leader key mappings
Plug 'liuchengxu/vim-which-key'
" -- convert color values to different formats
Plug 'amadeus/vim-convert-color-to'
" -- mappings for different keyboard layout
Plug 'tizee/keyboard.vim'
" -- git blame / open git repo url
Plug 'tizee/vim-gh-line'
" -- search package in nodemodules in yarn/npm managed project
Plug 'tizee/nodemodules.vim'
" -- generate markdown table
Plug 'tizee/md-table.vim'
" -- convert rgb hex string to r,g,b
Plug 'tizee/hex2rgb.vim'
" -- convert unicode value to corresponding unicode character
" Plug 'tizee/unicode.vim'
Plug '/Users/tizee/projects/project-vim/tizee-plugins/unicode.vim'
" -- copy text to the system clipboard from anywhere using the ANSI OSC52 sequence
Plug 'ojroques/vim-oscyank'
if has('nvim')
  " -- swap values in ternary expressions
  Plug 'xlboy/swap-ternary.nvim'
endif
" }}}
"
" ===> Git plugins {{{
" -- git operations commands
Plug 'tpope/vim-fugitive'
" -- display git gutter signs in signcolumn
Plug 'airblade/vim-gitgutter' " git
" }}}

" ===> Snippets {{{
" -- ultisnips
" Plug 'SirVer/ultisnips'
" }}}

" ===> UI {{{
" -- statusline
Plug 'tizee/moline.vim'
Plug 'tizee/moline.vim'
" -- tabline
Plug 'tizee/tabline.vim'
" -- Nerdfont icons
Plug 'tizee/vim-devicons'
" -- colorscheme
Plug 'tizee/gruvbox.vim'
" -- start screen
Plug 'mhinz/vim-startify'
" -- zen mode
Plug 'junegunn/goyo.vim'
" Indent
" -- Show vertical lines for indent with conceal feature
Plug 'Yggdroot/indentLine'

" }}}

" ===> Debugging {{{
" Plug 'puremourning/vimspector'

" }}}

" ===> File manager {{{
" -- nerdtree
Plug 'preservim/nerdtree'
" -- nerdtree with git status support
Plug 'tizee/nerdtree-git-plugin'
" -- vifm
" Plug 'vifm/vifm.vim'

" }}}

" ===> Editor Statistics {{{
" -- Wakatime
Plug 'wakatime/vim-wakatime'
" }}}

" ===> Vim Functions {{{
" -- find file path until root
Plug 'tizee/findfirst.vim', {'branch': 'master'}
" }}}

" ===> LSP {{{
" -- LSP + nvim nodejs ABI for ts plugins
" -- use my forked of coc.nvim
Plug 'tizee/coc.nvim', {'branch': 'master', 'do': 'pnpm run install --frozen-lockfile'}
" -- lua lsp: coc-stylua
" -- golang lsp: coc-go
" -- conflicts with coc-go
" Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }
" -- symbol tags
" it's the same as :CocOutline directly
Plug 'liuchengxu/vista.vim'
" }}}

" ===> AI {{{

" simple inline AI chat
Plug '~/projects/project-vim/tizee-plugins/llm.nvim'

" }}}

call plug#end()
endif

" vim: foldmarker={{{,}}}:foldmethod=marker
" }}} init-packages.vim

" === init-coc-config.vim === {{{
" COC CONFIG {{{

" debug for coc.nvim development
"let $NVIM_COC_LOG_LEVEL='debug'

function! g:CheckBackSpace() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" https://github.com/neoclide/coc.nvim/wiki/Using-snippets#configure-snippets-workflow
" Use tab for trigger completion with characters ahead and navigate.
" NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" other plugin before putting this into your config.

inoremap <silent><expr> <TAB>
      \ pumvisible() ? coc#_select_confirm() :
      \ coc#expandableOrJumpable() ? "\<C-r>=coc#rpc#request('doKeymap', ['snippets-expand-jump',''])\<CR>" :
      \ CheckBackSpace() ? "\<TAB>" :
      \ coc#refresh()

" Use <Tab> and <S-Tab> to navigate the completion list:
inoremap <expr> <Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
" inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

" Use K to show documentation in preview window.
nnoremap <silent> K :call <SID>show_documentation()<CR>
" close floating windows
nnoremap <silent> <C-x> :call coc#float#close_auto_hide_wins()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

" use <c-f> and <c-b> for scrolling in float/popup windows
if has('nvim-0.4.0') || has('patch-8.2.0750')
  inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<C-f>"
  inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<C-b>"
  nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
  vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
endif

" https://github.com/neoclide/coc.nvim/wiki/Using-snippets#snippet-completion
" Coc only does snippet and additional edit on confirm.
" <cr> could be remapped by other vim plugin, try `:verbose imap <CR>`.

" Use <cr> to confirm completion, `<C-g>u` means break undo chain at current position.
inoremap <silent><expr> <cr> pumvisible() ? coc#_select_confirm() :
                                           \"\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

" GoTo code navigation.
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" Highlight the symbol and its references when holding the cursor.
autocmd CursorHold * silent call CocActionAsync('highlight')

" Symbol renaming.
nmap <leader>rn <Plug>(coc-rename)

" Formatting selected code.
xmap <leader>F  <Plug>(coc-format-selected)
nmap <leader>F  <Plug>(coc-format-selected)

augroup CocAuGroup
  autocmd!
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

" Applying codeAction to the selected region.
" Example: `<leader>aap` for current paragraph
nnoremap <leader>as  <Plug>(coc-codeaction-selected)
nnoremap <leader>ac  <Plug>(coc-codeaction-cursor)
nnoremap <leader>al  <Plug>(coc-codelens-action)

" Remap keys for applying codeAction to the current buffer.
" nmap <leader>aa  <Plug>(coc-codeaction)
" Apply AutoFix to problem on the current line.
nmap <leader>qf  <Plug>(coc-fix-current)

" Map function and class text objects
" use nvim-treesitter-textobjects for nvim
if !has('nvim')
" NOTE: Requires 'textDocument.documentSymbol' support from the language server.
  xmap if <Plug>(coc-funcobj-i)
  omap if <Plug>(coc-funcobj-i)
  xmap af <Plug>(coc-funcobj-a)
  omap af <Plug>(coc-funcobj-a)
  xmap ic <Plug>(coc-classobj-i)
  omap ic <Plug>(coc-classobj-i)
  xmap ac <Plug>(coc-classobj-a)
  omap ac <Plug>(coc-classobj-a)
  " Use CTRL-S for selections ranges.
  " Requires 'textDocument/selectionRange' support of language server.
  nmap <silent> <C-s> <Plug>(coc-range-select)
  xmap <silent> <C-s> <Plug>(coc-range-select)
endif


" Add `:Format` command to format current buffer.
command! -nargs=0 Format :call CocAction('format')

" Add `:Fold` command to fold current buffer.
command! -nargs=? Fold :call     CocAction('fold', <f-args>)

" Add `:OR` command for organize imports of the current buffer.
command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

" Add (Neo)Vim's native statusline support.
" NOTE: Please see `:h coc-status` for integrations with external plugins that
" provide custom statusline: lightline.vim, vim-airline.
" set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

" Mappings for CoCList
" Open CocList
" nnoremap <silent> <space>g :<C-u>CocList --normal gstatus<cr>
" Show all diagnostics.
nnoremap <silent><nowait> <leader>ca  :<C-u>CocList diagnostics<cr>
" Manage extensions.
nnoremap <silent><nowait> <leader>ce  :<C-u>CocList extensions<cr>
" Show commands.
nnoremap <silent><nowait> <leader>cc  :<C-u>CocList commands<cr>
" Find symbol of current document.
nnoremap <silent><nowait> <leader>co  :<C-u>CocList outline<cr>
" Search workspace symbols.
nnoremap <silent><nowait> <leader>cs  :<C-u>CocList -I symbols<cr>
" Do default action for next item.
nnoremap <silent><nowait> <space>cj  :<C-u>CocNext<CR>
" Do default action for previous item.
nnoremap <silent><nowait> <leader>ck  :<C-u>CocPrev<CR>
" Resume latest coc list.
nnoremap <silent><nowait> <leader>cp  :<C-u>CocListResume<CR>

" use ctrl-p for CocList
nnoremap <silent><nowait> <C-p> :<C-u>CocList<CR>

" use ctrl-o for CocOutline
" nnoremap <silent><nowait> <C-o> :<C-U>CocOutline<CR>
" use ctrl-q for CocDiagnostics
" Use `[g` and `]g` to navigate diagnostics
" Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
nmap <silent><nowait> <C-q> :<c-u>CocDiagnostics<CR>
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" Use <C-l> for trigger snippet expand.
inoremap <C-l> <Plug>(coc-snippets-expand)

" Use <C-j> for select text for visual placeholder of snippet.
vnoremap <C-j> <Plug>(coc-snippets-select)

" Use <C-j> for jump to next placeholder, it's default of coc.nvim
let g:coc_snippet_next = '<C-j>'

" Use <C-k> for jump to previous placeholder, it's default of coc.nvim
let g:coc_snippet_prev = '<C-k>'

" Use <C-j> for both expand and jump (make expand higher priority.)
" imap <C-j> <Plug>(coc-snippets-expand-jump)

" Use <leader>x for convert visual selected code to snippet
xmap <leader>x  <Plug>(coc-convert-snippet)
" Use <leader>x to close all floating windows in some buggy situations
nmap <silent> <leader>x  :call coc#float#close_all()<CR>

"}}}

" vim:ft=vim
" }}} init-coc-config.vim

" === init-fzf.vim === {{{
" see https://github.com/junegunn/fzf/blob/master/README-VIM.md
"
" fzf#run([spec dict])
" Starts fzf inside Vim with the given spec
" :call fzf#run({'source': 'ls'})
" fzf#wrap([spec dict]) -> (dict)
" Takes a spec for fzf#run and returns an extended version of it with additional options for addressing global preferences (g:fzf_xxx)
" :echo fzf#wrap({'source': 'ls'})
" We usually wrap a spec with fzf#wrap before passing it to fzf#run
" :call fzf#run(fzf#wrap({'source': 'ls'}))
" :FZF [fzf_options string] [path string]
" Basic fuzzy file selector
" A reference implementation for those who don't want to write VimScript to implement custom commands
" If you're looking for more such commands, check out fzf.vim project.
"
" g:fzf_action
" Customizable extra key bindings for opening selected files in different ways
" g:fzf_layout
" Determines the size and position of fzf window
" g:fzf_colors
" Customizes fzf colors to match the current color scheme
" g:fzf_history_dir
" Enables history feature
"
if !exists('g:loaded_tz_fzf_vim') && !&cp && v:version >= 700
  let g:loaded_tz_fzf_vim = 1
let s:is_win = has('win32') || has('win64')
let s:bin_dir = get(g:, 'vim_config_dir', expand('~/.config/nvim/')) . 'fzf-scripts/'
let s:bin = {
\ 'preview': s:bin_dir.'preview.sh',
\ 'tags':    s:bin_dir.'tags.pl' }
let s:TYPE = {'dict': type({}), 'funcref': type(function('call')), 'string': type(''), 'list': type([])}
if s:is_win
  if has('nvim')
    let s:bin.preview = split(system('for %A in ("'.s:bin.preview.'") do @echo %~sA'), "\n")[0]
  else
    let s:bin.preview = fnamemodify(s:bin.preview, ':8')
  endif
endif

" fzf general options {{{
" nnoremap <C-c> <nop>
let $FZF_DEFAULT_OPTS .= ' --inline-info --reverse' " --bind ctrl-c:select-all
" Enable per-command history
" - History files will be stored in the specified directory
" - When set, CTRL-N and CTRL-P will be bound to 'next-history' and
"   'previous-history' instead of 'down' and 'up'.
let g:fzf_history_dir = '~/.local/share/fzf-history'

" send results to quickfix list from fzf result
" https://github.com/junegunn/fzf.vim/issues/185

function! s:make_quickfix_list(lines)
  call setqflist(map(copy(a:lines),'{ "filename": v:val }' ))
  copen
  cc
endfunction

let g:fzf_action = {
      \ 'ctrl-q': function('s:make_quickfix_list'),
      \ 'ctrl-e': 'edit',
      \ 'ctrl-t': 'tab split',
      \ 'ctrl-x': 'split',
      \ 'ctrl-v': 'vsplit' }

let s:default_action = g:fzf_action

" git commit
let g:fzf_commits_log_options = '--graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr"'

let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

" Terminal buffer options for fzf
augroup TZFZF
autocmd! FileType fzf
autocmd! FileType fzf set noshowmode noruler nonu nornu signcolumn=no foldcolumn=0 nocursorline
augroup END "TZFZF

" list/preview split defaults
if !exists('g:fzf_list_ratio')
  let g:fzf_list_ratio = 60
endif
if !exists('g:fzf_preview_ratio')
  let g:fzf_preview_ratio = 40
endif
if !exists('g:fzf_preview_window')
  let ratio = g:fzf_preview_ratio > 0 ? g:fzf_preview_ratio : (100 - g:fzf_list_ratio)
  let ratio = max([10, min([90, ratio])])
  let g:fzf_preview_window = 'right:' . ratio . '%'
endif

" let g:fzf_preview_window = 'right:60%'
if !has('nvim') && exists('$TMUX')
  let g:fzf_layout = { 'tmux': '-p90%,60%' }
endif

if has('nvim')
  if !exists('g:fzf_window_padding_x')
    let g:fzf_window_padding_x = 10
  endif
  if !exists('g:fzf_window_padding_y')
    let g:fzf_window_padding_y = 2
  endif
  if !exists('g:fzf_window_border_gap')
    let g:fzf_window_border_gap = 2
  endif

  if exists('&winblend') && &termguicolors
    set winblend=20

    hi NormalFloat guibg=None
    if exists('g:fzf_colors.bg')
       call remove(g:fzf_colors, 'bg')
    endif
  endif

  if stridx($FZF_DEFAULT_OPTS, '--border') == -1
    let $FZF_DEFAULT_OPTS .= ' --border'
  endif

  function! FloatingFZF()
    let pad_x = g:fzf_window_padding_x
    let pad_y = g:fzf_window_padding_y
    let gap = g:fzf_window_border_gap
    let width = max([1, &columns - (pad_x * 2) - gap])
    let height = max([1, &lines - (pad_y * 2) - gap])
    let opts = { 'relative': 'editor',
               \ 'row': pad_y,
               \ 'col': pad_x,
               \ 'width': width,
               \ 'height': height,
               \ 'style': 'minimal' }

    let win = nvim_open_win(nvim_create_buf(v:false, v:true), v:true, opts)
    call nvim_win_set_option(win, 'winhl', 'NormalFloat:Normal')
    return win
  endfunction

  let g:fzf_layout = { 'window': 'call FloatingFZF()' }
endif
" }}}

" fzf enhanced commands {{{

" utilities {{{
function! s:extend_opts(dict, eopts, prepend)
  if empty(a:eopts)
    return
  endif
  if has_key(a:dict, 'options')
    if type(a:dict.options) == s:TYPE.list && type(a:eopts) == s:TYPE.list
      if a:prepend
        let a:dict.options = extend(copy(a:eopts), a:dict.options)
      else
        call extend(a:dict.options, a:eopts)
      endif
    else
      let all_opts = a:prepend ? [a:eopts, a:dict.options] : [a:dict.options, a:eopts]
      let a:dict.options = join(map(all_opts, 'type(v:val) == s:TYPE.list ? join(map(copy(v:val), "fzf#shellescape(v:val)")) : v:val'))
    endif
  else
    let a:dict.options = a:eopts
  endif
endfunction

function! s:merge_opts(dict, eopts)
  return s:extend_opts(a:dict, a:eopts, 0)
endfunction

function! s:prepend_opts(dict, eopts)
  return s:extend_opts(a:dict, a:eopts, 1)
endfunction

function! s:shortpath()
  let short = fnamemodify(getcwd(), ':~:.')
  if !has('win32unix')
    let short = pathshorten(short)
  endif
  let slash = (s:is_win && !&shellslash) ? '\' : '/'
  return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)
endfunction

function! s:cwd_prompt()
  let prompt = s:shortpath()
  return strwidth(prompt) < &columns - 20 ? prompt : '> '
endfunction

function! s:wrap(name, opts, bang)
  " fzf#wrap does not append --expect if sink or sink* is found
  let opts = copy(a:opts)
  let options = ''
  if has_key(opts, 'options')
    let options = type(opts.options) == s:TYPE.list ? join(opts.options) : opts.options
  endif
  if options !~ '--expect' && has_key(opts, 'sink*')
    let Sink = remove(opts, 'sink*')
    let wrapped = fzf#wrap(a:name, opts, a:bang)
    let wrapped['sink*'] = Sink
  else
    let wrapped = fzf#wrap(a:name, opts, a:bang)
  endif
  return wrapped
endfunction

function! s:fzf(name, opts, extra)
  let [extra, bang] = [{}, 0]
  if len(a:extra) <= 1
    let first = get(a:extra, 0, 0)
    if type(first) == s:TYPE.dict
      let extra = first
    else
      let bang = first
    endif
  elseif len(a:extra) == 2
    let [extra, bang] = a:extra
  else
    throw 'invalid number of arguments'
  endif

  let eopts  = has_key(extra, 'options') ? remove(extra, 'options') : ''
  let merged = extend(copy(a:opts), extra)
  call s:merge_opts(merged, eopts)
  return fzf#run(s:wrap(a:name, merged, bang))
endfunction

function! s:action_for(key, ...)
  let default = a:0 ? a:1 : ''
  let Cmd = get(get(g:, 'fzf_action', s:default_action), a:key, default)
  return type(Cmd) == s:TYPE.string ? Cmd : default
endfunction

function! s:fill_quickfix(list, ...)
  if len(a:list) > 1
    call setqflist(a:list)
    copen
    wincmd p
    if a:0
      execute a:1
    endif
  endif
endfunction

function! s:ag_to_qf(line, has_column)
  let parts = matchlist(a:line, '\(.\{-}\)\s*:\s*\(\d\+\)\%(\s*:\s*\(\d\+\)\)\?\%(\s*:\(.*\)\)\?')
  let dict = {'filename': &acd ? fnamemodify(parts[1], ':p') : parts[1], 'lnum': parts[2], 'text': parts[4]}
  if a:has_column
    let dict.col = parts[3]
  endif
  return dict
endfunction

function! s:escape(path)
  let path = fnameescape(a:path)
  return s:is_win ? escape(path, '$') : path
endfunction

function! s:open(cmd, target)
  if stridx('edit', a:cmd) == 0 && fnamemodify(a:target, ':p') ==# expand('%:p')
    return
  endif
  execute a:cmd s:escape(a:target)
endfunction

function! s:ag_handler(lines, has_column)
  if len(a:lines) < 2
    return
  endif

  let cmd = s:action_for(a:lines[0], 'e')
  let list = map(filter(a:lines[1:], 'len(v:val)'), 's:ag_to_qf(v:val, a:has_column)')
  if empty(list)
    return
  endif

  let first = list[0]
  try
    call s:open(cmd, first.filename)
    execute first.lnum
    if a:has_column
      execute 'normal!' first.col.'|'
    endif
    normal! zz
  catch
  endtry

  call s:fill_quickfix(list)
endfunction

function! s:fzf_grep(grep_command, has_column, ...)
  let words = []
  for word in split(a:grep_command)
    if word !~# '^[a-z]'
      break
    endif
    call add(words, word)
  endfor
  let words   = empty(words) ? ['grep'] : words
  let name    = join(words, '-')
  let capname = join(map(words, 'toupper(v:val[0]).v:val[1:]'), '')
  let opts = {
  \ 'column':  a:has_column,
  \ 'options': ['--ansi', '--prompt', s:cwd_prompt(),
  \             '--multi', '--bind', 'alt-a:select-all,alt-d:deselect-all',
  \             '--delimiter', ':', '--preview-window', '+{2}-5',
  \             '--color', 'hl:4,hl+:12']
  \}
  function! opts.sink(lines)
    return s:ag_handler(a:lines, self.column)
  endfunction
  let opts['sink*'] = remove(opts, 'sink')
  try
    let prev_default_command = $FZF_DEFAULT_COMMAND
    let $FZF_DEFAULT_COMMAND = a:grep_command
    return s:fzf(name, opts, a:000)
  finally
    let $FZF_DEFAULT_COMMAND = prev_default_command
  endtry
endfunction

function! s:fzf_with_preview(...)
  " Default spec
  let spec = {}
  let window = ''
  let preview_offset = ''

  let args = copy(a:000)

  " Spec to wrap
  if len(args) && type(args[0]) == s:TYPE.dict
    let spec = copy(args[0])
    call remove(args, 0)
  endif

  if has_key(spec, 'options') && type(spec.options) == s:TYPE.list
    let idx = index(spec.options, '--preview-window')
    if idx >= 0 && idx + 1 < len(spec.options)
      let preview_offset = spec.options[idx + 1]
      call remove(spec.options, idx + 1)
      call remove(spec.options, idx)
    endif
  endif

  if !executable('bash')
    if !s:warned
      call s:warn('Preview window not supported (bash not found in PATH)')
      let s:warned = 1
    endif
    return spec
  endif

  " Placeholder expression (TODO/TBD: undocumented)
  let placeholder = get(spec, 'placeholder', '{}')

  " Preview window
  if len(args) && type(args[0]) == s:TYPE.string
    if args[0] !~# '^\(up\|down\|left\|right\)'
      throw 'invalid preview window: '.args[0]
    endif
    let window = args[0]
    call remove(args, 0)
  elseif exists('g:fzf_preview_window')
    let window = g:fzf_preview_window
  else
    let window = 'right:40%'
  endif

  if len(preview_offset)
    if preview_offset =~# '^\(+\|{\)'
      let window = window . ':' . preview_offset
    else
      let window = preview_offset
    endif
  endif

  let preview = []
  if len(window)
    let preview += ['--preview-window', window]
  endif
  if s:is_win
    let is_wsl_bash = exepath('bash') =~? 'Windows[/\\]system32[/\\]bash.exe$'
    let preview_cmd = 'bash '.(is_wsl_bash
    \ ? substitute(substitute(s:bin.preview, '^\([A-Z]\):', '/mnt/\L\1', ''), '\', '/', 'g')
    \ : escape(s:bin.preview, '\'))
  else
    let preview_cmd = fzf#shellescape(s:bin.preview)
  endif
  let preview += ['--preview', preview_cmd.' '.placeholder]

  if len(args)
    call extend(preview, ['--bind', join(map(args, 'v:val.":toggle-preview"'), ',')])
  endif
  call s:merge_opts(spec, preview)
  return spec
endfunction
" }}}

" All files with fd {{{
command! -nargs=? -complete=dir AF
  \ call fzf#run(fzf#wrap(s:fzf_with_preview({
  \   'source': 'fd --color=never --type f --hidden --follow --exclude .git --no-ignore ' . <q-args>,
  \   'options': ['--prompt', s:cwd_prompt()]
  \ })))
" }}}

" file search with fd {{{
command! -bang -nargs=* -complete=dir FD
  \ call fzf#run(fzf#wrap('fd', s:fzf_with_preview({
  \   'source': 'fd --color=never --type f --hidden --follow --exclude .git --no-ignore ' . <q-args>,
  \   'options': ['--prompt', s:cwd_prompt()]
  \ }), <bang>0))
" }}}

" file search with ag {{{
command! -bang -nargs=* AG
      \ call fzf#vim#ag(<q-args>,
      \                 <bang>0 ? s:fzf_with_preview('up:60%')
      \                         : s:fzf_with_preview('right:40%', '?'),
      \                 <bang>0)
" }}}

" content search with ripgrep {{{
function! s:ripgrepFzf(query, fullscreen)
  let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case -- %s'
  let initial_command = printf(command_fmt, shellescape(a:query))
  let reload_command = printf(command_fmt, '{q} || true')
  let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
  call s:fzf_grep(initial_command, 1, s:fzf_with_preview(spec), a:fullscreen)
endfunction

command! -nargs=* -bang RG call <SID>ripgrepFzf(<q-args>, <bang>0)

function! s:rgWordFzf(query, fullscreen)
  " get word
  let word = execute('normal viwy')
  if len(word)
    let command_fmt = 'rg --column --line-number --no-heading --color=always --smart-case -- %s || true'
    let initial_fmt= 'rg --column --line-number --no-heading --color=always --smart-case ' . word . ' || true'
    let reload_command = printf(command_fmt, '{q}')
    let spec = {'options': ['--phony', '--query', a:query, '--bind', 'change:reload:'.reload_command]}
    call s:fzf_grep(initial_command, 1, s:fzf_with_preview(spec), a:fullscreen)
  endif
  " throw error
endfunction

command! -nargs=* -bang RgWordFzf call <SID>rgWordFzf(<q-args>, <bang>0)
" }}}


" git grep {{{
command! -bang -nargs=* GGrep
  \ call s:fzf_grep(
  \   'git grep --line-number -- '.shellescape(<q-args>), 0,
  \   s:fzf_with_preview({'dir': systemlist('git rev-parse --show-toplevel')[0]}), <bang>0)
" }}}

" plug help {{{
if exists('g:plugs')
  function! s:plug_help_sink(line)
    let dir = g:plugs[a:line].dir
    for path in ['doc/*.text','README.md']
      let match = get(split(globpath(dir,path),"\n"),0,'')
      if len(match)
        " show in new tab
        execute 'tabedit' match
        return
      endif
    endfor
    tabnew
    execute 'Explore' dir
  endfunction

  command! PlugHelp call fzf#run(fzf#wrap({
    \ 'source': sort(keys(g:plugs)),
    \ 'sink': function('s:plug_help_sink')}))
endif
" }}}

" Quick edit oldfiles {{{
function! s:open_file(file) abort
  let absolute_path = resolve(a:file)
  if empty(absolute_path) || !filereadable(absolute_path)
    echohl Error
    echom "Cannnot read " . absolute_path
    echohl Normal
    return
  endif
  " show in new tab
  execute 'tabedit' absolute_path
endfunction

" v:oldfiles depends on 'shada' option
function! s:filter_oldfiles()
  let oldfiles = []
  for file in v:oldfiles
    if !isdirectory(file) && filereadable(file)
      call add(oldfiles, file)
    endif
  endfor
  return oldfiles
endfunction

command! -nargs=* Ze call fzf#run(fzf#wrap({
      \ 'source': s:filter_oldfiles(),
      \ 'sink': function('s:open_file')}))
" }}}

" list files {{{
" The query history for this command will be stored as 'ls' inside g:fzf_history_dir.
" The name is ignored if g:fzf_history_dir is not defined.
command! -bang -complete=dir -nargs=* LS
    \ call fzf#run(fzf#wrap('ls', {'source': 'ls', 'dir': <q-args>}, <bang>0))
" }}}

" buffer close {{{
function! s:list_buffers()
  redir => bf_list
  silent ls
  redir END
  return split(bf_list,"\n")
endfunction

function! s:close_buffers(lines)
  execute 'bwipeout' join(map(a:lines,{_,line -> split(line)[0]}))
endfunction

" close selected buffer
command! BD call fzf#run(fzf#wrap({
\ 'source': s:list_buffers(),
\ 'sink*': {lines -> s:close_buffers(lines)},
\ 'options': '--multi --reverse'
\ }))
" }}}

" Plugin Config Helpers {{{

" list config files
function! s:list_my_configs()
  return ['package-config']
endfunction

" open custom plugin config file
function! s:open_my_config_sink(line)
  let dir = get(g:, 'vim_config_dir', resolve(expand('~/.config/nvim/')))
  let match = dir . a:line . '.vim'
  if filereadable(match)
    " show in new tab
    execute 'tabedit' match
    return
  endif
  tabnew
  execute 'Explore' dir
endfunction

command! PlugConfig call fzf#run(fzf#wrap({
  \ 'source': s:list_my_configs(),
  \ 'sink': {lines -> s:open_my_config_sink(lines)},
  \ 'options': '--preview-window hidden'
  \ }))

" }}}

" }}}

" fzf mappings{{{
nnoremap <leader>fb :BD<CR>
nnoremap <leader>fg :GGrep<CR>
nnoremap <leader>fa :AG<CR>
nnoremap <leader>fr :RG<CR>
nnoremap <leader>fh :PlugHelp<CR>
" }}}

endif

" }}} init-fzf.vim

" === init-gitgutter.vim === {{{
" see :help gitgutter

" Determines whether or not to show signs.
let g:gitgutter_signs=1

" Determines whether or not to show line highlights.
let g:gitgutter_highlight_lines=0

" Determines whether or not to show line number highlights.
let g:gitgutter_highlight_linenrs=1

" Sets the maximum number of signs to show in a buffer.
" Default: 500 (Vim < 8.1.0614, Neovim < 0.4.0) -1 (otherwise)
let g:gitgutter_max_signs=500

" Sets the |sign-priority| gitgutter assigns to its signs.
let g:gitgutter_sign_priority=10

" Determines whether gitgutter preserves non-gitgutter signs. When 1, gitgutter
" will not preserve non-gitgutter signs.
let g:gitgutter_sign_allow_clobber=0

let g:gitgutter_sign_added              = '┃'
let g:gitgutter_sign_modified           = '┃'
let g:gitgutter_sign_removed            = '┃'
let g:gitgutter_sign_removed_first_line = '‾'
let g:gitgutter_sign_removed_above_and_below = '_'
let g:gitgutter_sign_modified_removed   = '~'

" Only applies to existing GitGutter* highlight groups.
let g:gitgutter_set_sign_backgrounds=0

" update the signs when you save a file
autocmd BufWritePost * GitGutter
" }}} init-gitgutter.vim

" === init-goyo.vim === {{{
"====================
" goyo.vim
"====================
if !exists('g:loaded_tzgoyo_vim') && !&cp && v:version >= 700
  let g:loaded_tzgoyo_vim = 1
" listchars
let s:saved_lcs=&lcs
function! s:on_goyo_enter()
  if exists('$TMUX')
    set lcs&vim
    silent !tmux set status off
  endif
endfunction

function! s:on_goyo_leave()
  if exists('$TMUX')
    let &lcs=s:saved_lcs
    silent !tmux set status on
  endif
endfunction

augroup TzGoyo
  autocmd!
  autocmd! User GoyoEnter nested call <SID>on_goyo_enter()
  autocmd! User GoyoLeave nested call <SID>on_goyo_leave()
augroup END "TzGoyo

nnoremap <leader>G :Goyo<CR>

" vim:set foldmethod=marker
endif
" }}} init-goyo.vim

" === init-hexokinase.vim === {{{
if !exists('g:loaded_init_hexokinase_vim') && !&cp && v:version >= 700
  let g:loaded_init_hexokinase_vim = 1

" Neovim default
" let g:Hexokinase_highlighters = [ 'virtual' ]

" Vim default
let g:Hexokinase_highlighters = [ 'sign_column' ]

" All possible highlighters
" let g:Hexokinase_highlighters = [
" \   'virtual',
" \   'sign_column',
" \   'background',
" \   'backgroundfull',
" \   'foreground',
" \   'foregroundfull'
" \ ]

" Patterns to match for all filetypes
" Can be a comma separated string or a list of strings
" Default value:
let g:Hexokinase_optInPatterns = 'full_hex,rgb,rgba,hsl,hsla,colour_names'

" All possible values
let g:Hexokinase_optInPatterns = [
\     'full_hex',
\     'triple_hex',
\     'rgb',
\     'rgba',
\     'hsl',
\     'hsla',
\     'colour_names'
\ ]

" Filetype specific patterns to match
" entry value must be comma seperated list
let g:Hexokinase_ftOptInPatterns = {
\     'css': 'full_hex,rgb,rgba,hsl,hsla,colour_names',
\     'html': 'full_hex,rgb,rgba,hsl,hsla,colour_names'
\ }

" Sample value, to keep default behaviour don't define this variable
let g:Hexokinase_ftEnabled = ['css', 'html', 'javascript', 'tex', 'zsh', 'sh', 'conf']
endif
" }}} init-hexokinase.vim

" === init-indentLine.vim === {{{
" File: init-indentLine.vim
" Author: tizee
" Email: 33030965+tizee@users.noreply.github.com
" Description:

let g:indentLine_fileTypeExclude=['startify', 'nerdtree']
let g:indentLine_char='|'
" keep your setting for conceallevel, set it to 0
let g:indentLine_setConceal=0
let g:indentLine_faster=1
let g:indentLine_concealcursor='nc'
let g:indentLine_char_list = ['|', '¦', '┆', '┊']

" vim:set foldmethod=marker
" }}} init-indentLine.vim

" === init-keyboard.vim === {{{
let g:keyboard_autoresource=1
let g:keyboard_default_layout='qwerty'
if $COLEMAK_KEYBOARD == 1
"let g:keyboard_default_layout='colemak'
else
" let g:keyboard_default_layout='qwerty'
endif
let g:keyboard_layout_paths = {
      \  'colemak': expand("$HOME/.config/nvim/keyboard/colemak.vim"),
      \  'qwerty': expand("$HOME/.config/nvim/keyboard/qwerty.vim")
      \ }

" }}} init-keyboard.vim

" === init-languagetool.vim === {{{
if !exists('g:loaded_tz_languagetool_vim')
  let g:loaded_tz_languagetool_vim = 1

let g:languagetool_cmd="/usr/local/bin/languagetool"

endif
" }}} init-languagetool.vim

" === init-leaderf.vim === {{{
"====================
" leaderf configuration
" - vim7.3 or higher. Only support 7.4.1126+ after [v1.01](https://github.com/Yggdroot/LeaderF/releases/tag/v1.01).
" - Python2.7+ or Python3.1+.
" - To use the popup mode, neovim 0.42+ or vim 8.1.1615+ are required.
"====================
if !exists('g:loaded_leaderf_conf') && !&cp && v:version >= 741 && exists('*LeaderF')
  let g:loaded_leaderf_conf= 1

" don't show the help in normal mode
let g:Lf_HideHelp = 0
let g:Lf_UseCache = 0
let g:Lf_UseVersionControlTool = 0
let g:Lf_IgnoreCurrentBufferName = 1
" popup mode
let g:Lf_WindowPosition = 'popup'
let g:Lf_PreviewInPopup = 1
let g:Lf_StlSeparator = { 'left': "\ue0b0", 'right': "\ue0b2", 'font': "DejaVu Sans Mono for Powerline" }
let g:Lf_PreviewResult = {'Function': 0, 'BufTag': 0 }

let g:Lf_ShortcutF = "<leader>ff"
noremap <leader>fb :<C-U><C-R>=printf("Leaderf buffer %s", "")<CR><CR>
noremap <leader>fm :<C-U><C-R>=printf("Leaderf mru %s", "")<CR><CR>
noremap <leader>ft :<C-U><C-R>=printf("Leaderf bufTag %s", "")<CR><CR>
noremap <leader>fl :<C-U><C-R>=printf("Leaderf line %s", "")<CR><CR>

" conflict with coc keymap on scrolling in floating window
" noremap <C-B> :<C-U><C-R>=printf("Leaderf! rg --current-buffer -e %s ", expand("<cword>"))<CR>
" noremap <C-F> :<C-U><C-R>=printf("Leaderf! rg -e %s ", expand("<cword>"))<CR>
" search visually selected text literally
xnoremap gf :<C-U><C-R>=printf("Leaderf! rg -F -e %s ", leaderf#Rg#visual())<CR>
noremap go :<C-U>Leaderf! rg --recall<CR>

" should use `Leaderf gtags --update` first
let g:Lf_GtagsAutoGenerate = 0
let g:Lf_Gtagslabel = 'native-pygments'
noremap <leader>fr :<C-U><C-R>=printf("Leaderf! gtags -r %s --auto-jump", expand("<cword>"))<CR><CR>
noremap <leader>fd :<C-U><C-R>=printf("Leaderf! gtags -d %s --auto-jump", expand("<cword>"))<CR><CR>
noremap <leader>fo :<C-U><C-R>=printf("Leaderf! gtags --recall %s", "")<CR><CR>
noremap <leader>fn :<C-U><C-R>=printf("Leaderf gtags --next %s", "")<CR><CR>
noremap <leader>fp :<C-U><C-R>=printf("Leaderf gtags --previous %s", "")<CR><CR>

endif
" }}} init-leaderf.vim

" === init-llm.vim === {{{
let g:llm_api_keys_path = expand('$HOME/.config/io.datasette.llm/keys.json')
let g:llm_logs_path = expand('$HOME/.config/llm/llm_logs.db')
let g:llm_model_name = "deepseek-chat"
" }}} init-llm.vim

" === init-mappings.vim === {{{
" VIM COMPATIBLE KEY MAPPING {{{

nnoremap <space> <nop>
let mapleader = " "
let g:mapleader = " "
let maplocalleader = "\\"
" https://github.com/johndgiese/dotvim/issues/4
" https://vimhelp.appspot.com/term.txt.html#xterm-bracketed-paste
" Fix paste bug triggered by the above inoremaps
set t_BE=

" Normal Mode {{{

" virmrc/init.vim/init.lua
nnoremap <leader>ev :tabe $HOME/.config/nvim/vimrc.vim<cr>
nnoremap <leader>en :tabe $MYVIMRC<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>
nnoremap <leader>n :set rnu!<CR>
" disable arrow
noremap <Down> <nop>
noremap <Left> <nop>
noremap <Right> <nop>
noremap <Up> <nop>

" quick save
nnoremap S :w<cr>
" quick exit
nnoremap Q :q<cr>

" join lines without adding spaces
nnoremap J gJ
" clone current line
noremap Y y$

" termianl shortcut
" create terminal window then move it to the very bottom
function! s:create_terminal_panel()
  if !has("nvim")
    let t:terminal_name="terminal_buffer"
    silent! execute "bo split new"
    silent! execute "edit " . t:termianl_name
    silent! execute "resize 10"
    silent! execute "bo terminal"
  else
    silent! execute "bo split term://zsh"
    silent! execute "resize 10"
  endif
endfunction
nnoremap <leader>t :call<SID>create_terminal_panel()<CR>

" enter command mode quickly
" nnoremap ; :

" copy to/paste from system clipboard
nnoremap <leader>y "+y
nnoremap <leader>p "+p

" clear heighlight
nnoremap <silent><leader><CR> :noh<CR>

" Press ` to change case (instead of ~)
nnoremap ` ~

" Quick Replace
nnoremap <leader>R :%s//g<left><left>

" Quick paste default copy register in command mode
nnoremap <leader>V :<C-R>"

" Quick search word under cursor using help
nnoremap <leader>? :help <C-R><C-W>

" tab navigation
nnoremap <leader>1 1gt
nnoremap <leader>2 2gt
nnoremap <leader>3 3gt
nnoremap <leader>4 4gt
nnoremap <leader>5 5gt

" }}}

" Insert Mode {{{
" uppercase inner word
inoremap <c-u> <esc>viwUi<esc>
inoremap ;; <ESC>
inoremap <ESC> <nop>
if empty($TMUX)
  inoremap <silent> <S-up> <ESC><C-u>i
  inoremap <silent> <S-down> <ESC><C-d>i
  inoremap <silent> <S-left> <ESC>I
  inoremap <silent> <S-right> <ESC>A
endif

inoremap [ []<left>
inoremap ( ()<left>
inoremap { {}<left>

" }}}

" Visual Mode {{{
vnoremap \ U
"inoremap <c-d> <esc>ddi

" quick replace
vnoremap <leader>R :s//g<left><left>
" quick search
" vnoremap // y/\V<C-r>=escape(@",'/\')<CR><CR>
" quick search all non-ascii characters
" vnoremap <leader>a :s/\([^\u0020-\u0070]*\)/\1/
" quick search all non-ascii characters (including control characters)
" vnoremap <leader>A :s/\([^\u0000-\u0070]*\)/\1/

" copy to/paste from system clipboard
vnoremap <leader>p "+p
vnoremap <leader>y "+y
" quick sort
vnoremap <leader>s :sort<CR>

" reverse selected text
vnoremap <leader>r c<C-O>:set revins<CR><C-R>"<Esc>:set norevins<CR>
" }}}

" Terminal Mode {{{
if has("nvim")
  autocmd TermOpen * setlocal nonu nornu
  tnoremap <m-H> <nop>
  tnoremap <m-J> <nop>
  tnoremap <m-K> <nop>
  tnoremap <m-L> <nop>
  " simulate i_CTRL-R
  tnoremap <Esc> <C-\><C-n>
else
  " vim change terminal into Normal mode
  " see help terminal
  tnoremap <Esc> <C-W>N
endif

" }}}

" }}}

" vim:ft=vim foldmethod=marker
" }}} init-mappings.vim

" === init-moline.vim === {{{
let g:moline_git_status_icons = {
      \ 'added': '+',
      \ 'modified': '~',
      \ 'removed': '-',
      \}
" }}} init-moline.vim

" === init-nerdtree.vim === {{{
" NerdTree {{{

" When displaying directory nodes, this setting tells NERDTree to collapse directories that have only one child. Use one of the following lines for this setting
let NERDTreeCascadeSingleChildDir=0
" This setting disables the 'Bookmarks' label 'Press ? for help' text. Use one
" of the following lines for this setting: >
let NERDTreeMinimalUI=1
let NERDTreeShowHidden=1
" Tells the NERDTree whether to display the bookmarks table on startup.
let NERDTreeShowBookmarks=1
" Where the bookmarks are stored.
let NERDTreeBookmarksFile=expand("$HOME/.NERDTreeBookmarks")
" Can be enabled or disabled
let g:webdevicons_enable_nerdtree = 1
" whether or not to show the nerdtree brackets around flags
let g:webdevicons_conceal_nerdtree_brackets = 0

let g:NERDTreeGitStatusUseNerdFonts = 1 " you should install nerdfonts by yourself. default: 0
let g:NERDTreeIgnore = ['^node_modules$']
let g:NERDTreeGitStatusIndicatorMapCustom = {
                \ 'Modified'  :'!',
                \ 'Staged'    :'+',
                \ 'Untracked' :'?',
                \ 'Renamed'   :'->',
                \ 'Unmerged'  :'═',
                \ 'Deleted'   :'Del',
                \ 'Dirty'     :'*',
                \ 'Ignored'   :'Ig',
                \ 'Clean'     :'Cl',
                \ 'Unknown'   :'??',
                \ }
" }}}

" Quick toggle file manager
" nerdtree
nnoremap <silent> <script> <Plug>ChangePWD2CurrentWindow :<c-u>lcd %:h<CR>

nnoremap <silent> tt :NERDTreeToggle<CR>
" nnoremap <leader>r :NERDTreeFind<cr>
nnoremap <silent> <C-n> :<c-u>execute "normal \<Plug>ChangePWD2CurrentWindow"<CR>:<c-u>NERDTreeCWD<CR>

" vim:ft=vim sw=2
" }}} init-nerdtree.vim

" === init-rainbow.vim === {{{
" auto enable
let g:rainbow_active = 1

"enable rainbow for code blocks only
let g:rainbow_conf = {
\	'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'],
\	'ctermfgs': ['lightblue', 'lightyellow', 'lightcyan', 'lightmagenta'],
\	'guis': [''],
\	'cterms': [''],
\	'operators': '_,_',
\	'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/{/ end=/}/ fold'],
\	'separately': {
\		'*': {},
\		'markdown': {
\			'parentheses_options': 'containedin=markdownCode contained',
\		},
\		'lisp': {
\			'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick', 'darkorchid3'],
\		},
\		'haskell': {
\			'parentheses': ['start=/(/ end=/)/ fold', 'start=/\[/ end=/\]/ fold', 'start=/\v\{\ze[^-]/ end=/}/ fold'],
\		},
\		'vim': {
\			'parentheses_options': 'containedin=vimFuncBody',
\		},
\		'perl': {
\			'syn_name_prefix': 'perlBlockFoldRainbow',
\		},
\		'stylus': {
\			'parentheses': ['start=/{/ end=/}/ fold contains=@colorableGroup'],
\		},
\		'css': 0,
\		'nerdtree': 0,
\	}
\}
" }}} init-rainbow.vim

" === init-startify.vim === {{{
let s:default_slogan = [
\ '     __    __      __  __            __                 ',
\ '    /\ \  /\ \    /\ \/\ \          /\ \                ',
\ '    \ `\`\\/ / ___\ \ \_\ \     __  \ \ \___     ___    ',
\ '     `\ `\ / `/ __`\ \  _  \  /`__`\ \ \  _ `\  / __`\  ',
\ '       `\ \ \/\ \L\ \ \ \ \ \/\ \L\.\_\ \ \ \ \/\ \L\ \ ',
\ '         \ \_\ \____/\ \_\ \_\ \__/.\_\\ \_\ \_\ \____/ ',
\ '          \/_/\/___/  \/_/\/_/\/__/\/_/ \/_/\/_/\/___/  ',
\ '',
\ '',
\ ]

let s:colossal_slogan=[
      \'  888888                888   d8b ',
      \'   "88b                888   Y8P ',
      \'    888                888       ',
      \'    888 .d88b.  .d88b. 888888888 ',
      \'     888d8P  Y8bd8P  Y8b888   888 ',
      \'     8888888888888888888888   888 ',
      \'     88PY8b.    Y8b.    Y88b. 888 ',
      \'     888 "Y8888  "Y8888  "Y888888 ',
      \'   .d88P                          ',
      \' .d88P"                           ',
      \'888P"                             ',
\ '',
\ '',
      \]

let s:roman_slogan=[
      \'   oooo                         .    o8o  ',
      \'   `888                       .o8    `"`  ',
      \'    888  .ooooo.   .ooooo.  .o888oo oooo  ',
      \'    888 d88` `88b d88` `88b   888   `888  ',
      \'    888 888ooo888 888ooo888   888    888  ',
      \'    888 888    .o 888    .o   888 .  888  ',
      \'.o. 88P `Y8bod8P` `Y8bod8P`   "888" o888o ',
      \'`Y888P                                    ',
\ '',
\ '',
      \]

let s:logo=[
      \'████████╗██╗███████╗███████╗███████╗',
      \'╚══██╔══╝██║╚══███╔╝██╔════╝██╔════╝',
      \'   ██║   ██║  ███╔╝ █████╗  █████╗  ',
      \'   ██║   ██║ ███╔╝  ██╔══╝  ██╔══╝  ',
      \'   ██║   ██║███████╗███████╗███████╗',
      \'   ╚═╝   ╚═╝╚══════╝╚══════╝╚══════╝',
      \]

function! s:padstr(str,amt)
    return a:str . repeat(' ',a:amt - len(a:str))
endfunction

function s:longest(l) abort
  let max=0
  for line in a:l
    let llen = strlen(line)
    if llen > l:max
      let l:max = llen
    endif
  endfor
  return max
endfunction

" "kk-99",
" "learning",
" "song",
" "unix"
let s:quotes =[
      \ "naval-on-wealth",
      \ "naval-on-happiness",
      \ "naval-bonus",
      \]
let s:quote=system('fortune ' . join(s:quotes, " ") . ' | sed -r "s/.\[[0-9]*m//g"')
let s:quote_lines=split(s:quote,"\n")
let s:max_line=s:longest(s:quote_lines)
let s:quote_lines=map(s:quote_lines,{_,val->s:padstr(val, s:max_line)})
let g:startify_custom_header= startify#center(s:logo) +
      \ startify#pad(startify#center(s:quote_lines))

let g:startify_bookmarks = [ {'c': '~/.vimrc'}, '~/.zshrc' ]
" A list of commands to execute on selection. Leading colons are optional. It
" supports optional custom indices and/or command descriptions.
let g:startify_commands = [
    \ [':PlugConfig', 'PlugConfig'],
    \ ':CocInfo',
    \ {'h': 'h ref'},
    \ ]
" Startify displays lists. Each list consists of a `type` and optionally a `header`
" an custom `indices`.
let g:startify_lists = [
      \ { 'type': 'dir',       'header': ['   MRU '. getcwd()] },
      \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
      \ { 'type': 'commands',  'header': ['   Commands']       },
      \ ]

function! s:open_nerdtree()
    if !argc()
      NERDTree
      wincmd w
    endif
endfunction

" Startup with NERDTree opened
autocmd VimEnter * call <SID>open_nerdtree()

" vim:ft=vim
" }}} init-startify.vim

" === init-swap-ternary.vim === {{{
if has('nvim')
  nnoremap <leader>S :call swap_ternary#swap()<CR>
endif
" }}} init-swap-ternary.vim

" === init-tabular.vim === {{{
if exists(":Tabularize")
  nnoremap <Leader>a= :Tabularize /=<CR>
  vnoremap <Leader>a= :Tabularize /=<CR>
  nnoremap <Leader>a: :Tabularize /:\zs<CR>
  vnoremap <Leader>a: :Tabularize /:\zs<CR>
endif
" }}} init-tabular.vim

" === init-ultisnips.vim === {{{
" Trigger configuration. You need to change this to something other than <tab> if you use one of the following:
" - https://github.com/Valloric/YouCompleteMe
" - https://github.com/nvim-lua/completion-nvim
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<nop>"
let g:UltiSnipsJumpBackwardTrigger="<nop>"

let g:UltiSnipsSnippetDirectories=[$HOME .'/.config/nvim/UltiSnips']
" If you want :UltiSnipsEdit to split your window.
" let g:UltiSnipsEditSplit="vertical"

" }}} init-ultisnips.vim

" === init-unicode.vim === {{{
vnoremap <leader>u :'<,'>Unicode<CR>
vnoremap <leader>U :'<,'>GetUnicode<CR>
" }}} init-unicode.vim

" === init-utils.vim === {{{
" SCRIPTS {{{

function! s:openURL() abort
  let url = expand('<cfile>')
  if has('macunix') && executable('open')
    call system('open '.url)
    return
  elseif executable('xdg-open')
    call system('xdg-open '.url)
    return
  elseif has('win32') || has('win64')
    call system('cmd /c start "" /b '. substitute(url, '&', '^&', 'g'))
    if v:shell_error
      echohl Error | echom 'Failed to open '.url | echohl None
      return
    endif
  endif
endfunction

" alternative for broken netrwBrowseX
nnoremap <silent> <Plug>(gx-open-url) :call <SID>openURL()<CR>
nnoremap <silent> gx <Plug>(gx-open-url)

" }}}
" }}} init-utils.vim

" === init-vim-autoformat.vim === {{{
" let g:formatterpath = ['/usr/local/bin/astyle','/Users/tizee/.cargo/bin/rustfmt', '/usr/local/go/bin/gofmt']
" let b:formatdef_custom_c='"astyle --mode=c --style=kr"'
" let b:formatters_c = ['custom_c']
" }}} init-vim-autoformat.vim

" === init-vim-osc52.vim === {{{
" Use terminals that support oscyank
if exists(":OSCYank") == 2
  vnoremap <C-c> y:OSCYankVisual<cr>
else
  vnoremap <C-c> y:OSCYankVisual<cr>
endif
" }}} init-vim-osc52.vim

" === init-vimspector.vim === {{{
let g:vimspector_install_gadgets = [ 'debugpy', 'vscode-cpptools', 'CodeLLDB' ]
" }}} init-vimspector.vim

" === init-vista.vim === {{{
" How each level is indented and what to prepend.
" This could make the display more compact or more spacious.
" e.g., more compact: ["▸ ", ""]
" Note: this option only works for the kind renderer, not the tree renderer.
let g:vista_icon_indent = ["╰─▸ ", "├─▸ "]

" Executive used when opening vista sidebar without specifying it.
" See all the avaliable executives via `:echo g:vista#executives`.
let g:vista_default_executive = 'coc'

" Set the executive for some filetypes explicitly. Use the explicit executive
" instead of the default one for these filetypes when using `:Vista` without
" specifying the executive.
" let g:vista_executive_for = {
"   \ 'cpp': 'vim_lsp',
"   \ 'php': 'vim_lsp',
"   \ }

" Declare the command including the executable and options used to generate ctags output
" for some certain filetypes.The file path will be appened to your custom command.
" For example:
let g:vista_ctags_cmd = {
      \ 'haskell': 'hasktags -x -o - -c',
      \ }

" To enable fzf's preview window set g:vista_fzf_preview.
" The elements of g:vista_fzf_preview will be passed as arguments to fzf#vim#with_preview()
" For example:
let g:vista_fzf_preview = ['right:50%']

" Ensure you have installed some decent font to show these pretty symbols, then you can enable icon for the kind.
let g:vista#renderer#enable_icon = 1

" The default icons can't be suitable for all the filetypes, you can extend it as you wish.
let g:vista#renderer#icons = {
\   "function": "\Uf0295",
\   "variable": "\Uf021c",
\  }

nnoremap <leader>o :<C-U>Vista!!<CR>

" }}} init-vista.vim

" === init-which-key.vim === {{{

autocmd! FileType which_key
autocmd  FileType which_key set laststatus=0 noshowmode noruler
  \| autocmd BufLeave <buffer> set laststatus=2 showmode ruler

" show available key bindings for <leader>
nnoremap <silent> <leader> :<c-u>WhichKey '<Space>'<CR>
" show available key bindings for -
nnoremap <silent> <leader>- :<c-u>WhichKey '-'<CR>
" }}} init-which-key.vim

" === init-zig.vim === {{{
" format on save
let g:zig_fmt_autosave = 1
" }}} init-zig.vim

" vim:ft=vim foldmethod=marker
